import { createInterface } from "node:readline";
import { randomBytes } from "node:crypto";
import { existsSync, writeFileSync } from "node:fs";
import { execFileSync } from "node:child_process";

const ENV_FILE = ".env.prod";

const rl = createInterface({ input: process.stdin, output: process.stdout });
const ask = (q) => new Promise((r) => rl.question(q, r));

function genSecret() {
  return randomBytes(32).toString("hex");
}

function genApiKey() {
  return "API" + randomBytes(8).toString("hex");
}

console.log("Migo — Self-Hosted Setup");
console.log("========================\n");

// Check Docker
try {
  execFileSync("docker", ["--version"], { stdio: "pipe" });
} catch {
  console.error("Error: Docker is not installed. Install it from https://docs.docker.com/engine/install/");
  process.exit(1);
}

// Check Docker Compose
try {
  execFileSync("docker", ["compose", "version"], { stdio: "pipe" });
} catch {
  console.error("Error: Docker Compose is not available. Install it from https://docs.docker.com/compose/install/");
  process.exit(1);
}

if (existsSync(ENV_FILE)) {
  console.log(`Found existing ${ENV_FILE} — skipping generation.`);
  console.log("Delete it and re-run this script to regenerate.\n");
} else {
  // Detect public IP
  console.log("Detecting public IP...");
  let publicIp = "";
  try {
    const resp = await fetch("https://api.ipify.org", { signal: AbortSignal.timeout(5000) });
    publicIp = (await resp.text()).trim();
  } catch {
    try {
      const resp = await fetch("https://icanhazip.com", { signal: AbortSignal.timeout(5000) });
      publicIp = (await resp.text()).trim();
    } catch {
      // fallback to manual entry
    }
  }

  if (!publicIp) {
    publicIp = await ask("Could not detect public IP. Enter your server's public IP: ");
  } else {
    console.log(`Detected: ${publicIp}`);
    const confirm = await ask("Use this IP? (Y/n): ");
    if (/^[Nn]/.test(confirm)) {
      publicIp = await ask("Enter your server's public IP: ");
    }
  }

  // Generate secrets
  const postgresPassword = genSecret();
  const jwtAccessSecret = genSecret();
  const jwtRefreshSecret = genSecret();
  const livekitApiKey = genApiKey();
  const livekitApiSecret = genSecret();

  const date = new Date().toISOString().split("T")[0];
  const envContent = `# Generated by setup.mjs on ${date}

# PostgreSQL
POSTGRES_USER=migo
POSTGRES_PASSWORD=${postgresPassword}
POSTGRES_DB=migo

# JWT secrets
JWT_ACCESS_SECRET=${jwtAccessSecret}
JWT_REFRESH_SECRET=${jwtRefreshSecret}

# LiveKit (self-hosted, runs natively outside Docker)
# This URL is sent to clients so they can connect to LiveKit directly
LIVEKIT_URL=ws://${publicIp}:7880
LIVEKIT_API_KEY=${livekitApiKey}
LIVEKIT_API_SECRET=${livekitApiSecret}
`;

  writeFileSync(ENV_FILE, envContent);
  console.log(`\nCreated ${ENV_FILE} with generated secrets.`);
}

console.log("\nRequired ports (open these on your firewall):");
console.log("  443         UDP   — LiveKit TURN relay (screen share through NAT/firewalls)");
console.log("  8080        TCP   — Migo API + WebSocket");
console.log("  7880        TCP   — LiveKit signaling");
console.log("  7881        TCP   — LiveKit WebRTC (TCP fallback)");
console.log("  50000-60000 UDP   — LiveKit WebRTC media\n");

rl.close();

// Start everything in background
await import("./start-prod.mjs");
