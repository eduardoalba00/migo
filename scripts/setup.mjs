import { createInterface } from "node:readline";
import { randomBytes } from "node:crypto";
import { existsSync, writeFileSync } from "node:fs";
import { execFileSync } from "node:child_process";

const ENV_FILE = ".env.prod";

const rl = createInterface({ input: process.stdin, output: process.stdout });
const ask = (q) => new Promise((r) => rl.question(q, r));

function genSecret() {
  return randomBytes(32).toString("hex");
}

function genApiKey() {
  return "API" + randomBytes(8).toString("hex");
}

console.log("Migo — Self-Hosted Setup");
console.log("========================\n");

// Check Docker
try {
  execFileSync("docker", ["--version"], { stdio: "pipe" });
} catch {
  console.error("Error: Docker is not installed. Install it from https://docs.docker.com/engine/install/");
  process.exit(1);
}

// Check Docker Compose
try {
  execFileSync("docker", ["compose", "version"], { stdio: "pipe" });
} catch {
  console.error("Error: Docker Compose is not available. Install it from https://docs.docker.com/compose/install/");
  process.exit(1);
}

if (existsSync(ENV_FILE)) {
  console.log(`Found existing ${ENV_FILE} — skipping generation.`);
  console.log("Delete it and re-run this script to regenerate.\n");
} else {
  // Detect public IP
  console.log("Detecting public IP...");
  let publicIp = "";
  try {
    const resp = await fetch("https://api.ipify.org", { signal: AbortSignal.timeout(5000) });
    publicIp = (await resp.text()).trim();
  } catch {
    try {
      const resp = await fetch("https://icanhazip.com", { signal: AbortSignal.timeout(5000) });
      publicIp = (await resp.text()).trim();
    } catch {
      // fallback to manual entry
    }
  }

  if (!publicIp) {
    publicIp = await ask("Could not detect public IP. Enter your server's public IP: ");
  } else {
    console.log(`Detected: ${publicIp}`);
    const confirm = await ask("Use this IP? (Y/n): ");
    if (/^[Nn]/.test(confirm)) {
      publicIp = await ask("Enter your server's public IP: ");
    }
  }

  // HTTPS (optional — required for web client access)
  console.log("\nHTTPS is required for web client access (migovoice.com).");
  console.log("Prerequisites: a domain name pointing to this server + port 80 open for Let's Encrypt.\n");
  const wantHttps = await ask("Do you have a domain name for HTTPS? (y/N): ");
  let domain = "";
  if (/^[Yy]/.test(wantHttps)) {
    domain = (await ask("Enter your domain (e.g. migo.example.com): ")).trim();
  }

  // Generate secrets
  const postgresPassword = genSecret();
  const jwtAccessSecret = genSecret();
  const jwtRefreshSecret = genSecret();
  const livekitApiKey = genApiKey();
  const livekitApiSecret = genSecret();

  const date = new Date().toISOString().split("T")[0];
  let envContent = `# Generated by setup.mjs on ${date}

# PostgreSQL
POSTGRES_USER=migo
POSTGRES_PASSWORD=${postgresPassword}
POSTGRES_DB=migo

# JWT secrets
JWT_ACCESS_SECRET=${jwtAccessSecret}
JWT_REFRESH_SECRET=${jwtRefreshSecret}

# LiveKit
LIVEKIT_API_KEY=${livekitApiKey}
LIVEKIT_API_SECRET=${livekitApiSecret}
`;

  if (domain) {
    envContent += `
# HTTPS via Caddy reverse proxy
DOMAIN=${domain}
LIVEKIT_URL=wss://${domain}:8443
LIVEKIT_INTERNAL_URL=http://host.docker.internal:7880
`;
  } else {
    envContent += `
# LiveKit (self-hosted, runs natively outside Docker)
# This URL is sent to clients so they can connect to LiveKit directly
LIVEKIT_URL=ws://${publicIp}:7880
`;
  }

  writeFileSync(ENV_FILE, envContent);
  console.log(`\nCreated ${ENV_FILE} with generated secrets.`);
}

console.log("\nRequired ports (open these on your firewall):");
console.log("  443         UDP   — LiveKit TURN relay (screen share through NAT/firewalls)");
console.log("  8080        TCP   — Migo API + WebSocket (direct / Electron clients)");
console.log("  7881        TCP   — LiveKit WebRTC (TCP fallback)");
console.log("  50000-60000 UDP   — LiveKit WebRTC media");
console.log("\nHTTPS mode (if domain configured):");
console.log("  80          TCP   — Let's Encrypt ACME challenge + HTTP redirect");
console.log("  8443        TCP   — HTTPS reverse proxy (Caddy)\n");

rl.close();

// Start everything in background
await import("./start-prod.mjs");
